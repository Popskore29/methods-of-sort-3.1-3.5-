### **Анализ алгоритма: Сортировка выбором (Selection Sort)**
**Определение:**
Сортировка выбором (Selection Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.


**Анализ:**
*   Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.
*   Внешний цикл `for` выполняется `n-1` раз.
*   Внутренний цикл `for` в худшем случае выполняется `n-1`, затем `n-2`, ... раз за каждый проход внешнего цикла.
*   Общее количество сравнений примерно равно `n*(n-1)/2`.

**Временная сложность:** O(n²)

**Почему O(n²):** Два вложенных цикла, где каждый из них в среднем или худшем случае зависит от `n`. Внутренний цикл может выполняться до `n` раз для каждого из `n` итераций внешнего цикла, что приводит к квадратичной зависимости.

---

### **Анализ алгоритма: Сортировка обменом (пузырьком) (Bubble Sort)**
**Определение:**
Сортировка обменом (Bubble Sort) — это алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Этот процесс повторяется, пока массив не будет полностью отсортирован.

**Анализ:**
*   Алгоритм последовательно сравнивает пары соседних элементов.
*   Если порядок элементов неправильный, они меняются местами.
*   Внешний цикл `while` или `for` в худшем случае может выполняться до `n-1` раз.
*   Внутренний цикл `for` на каждом проходе просматривает неотсортированную часть массива, выполняя до `n-1` сравнений.
*   В худшем случае общее количество операций пропорционально `n*(n-1)/2`.

**Временная сложность:** O(n²)

**Почему O(n²):** Наличие двух вложенных циклов, каждый из которых в худшем случае выполняется пропорционально `n` раз. Даже в среднем случае требуется квадратичное число операций для "проталкивания" элементов на свои места.

---

### **Анализ алгоритма: Сортировка вставками (Insertion Sort)**
**Определение:**
Сортировка вставками (Insertion Sort) — это алгоритм, который строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию в уже отсортированной части массива.

**Анализ:**
*   Алгоритм обрабатывает элементы массива слева направо.
*   Для каждого нового элемента внутренний цикл `while` или `for` перемещает его влево по отсортированной части, пока не будет найдена правильная позиция.
*   В худшем случае (обратно отсортированный массив) для каждого элемента требуется сдвигать всю отсортированную часть, что требует `1 + 2 + ... + (n-1)` операций.
*   В лучшем случае (уже отсортированный массив) для каждого элемента требуется только одно сравнение.

**Временная сложность:** O(n²)

**Почему O(n²):** В худшем и среднем случае количество операций по вставке каждого нового элемента линейно зависит от размера уже отсортированной части, что в сумме дает квадратичную зависимость. Два вложенных цикла (внешний по всем элементам и внутренний для сдвигов) приводят к O(n²).

---

### **Анализ алгоритма: Сортировка слиянием (Merge Sort)**
**Определение:**
Сортировка слиянием (Merge Sort) — это алгоритм, который использует стратегию "разделяй и властвуй". Он рекурсивно разбивает массив на две половины до тех пор, пока не останутся подмассивы из одного элемента, а затем сливает эти подмассивы в отсортированном порядке.

**Анализ:**
*   Алгоритм состоит из двух основных этапов: разделение и слияние.
*   Глубина рекурсии составляет `log₂ n` уровней, так как массив каждый раз делится пополам.
*   На каждом уровне рекурсии выполняется операция слияния для всех `n` элементов (объединение двух отсортированных подмассивов в один — линейная операция).
*   Таким образом, общая работа на всех уровнях рекурсии пропорциональна `n * log n`.

**Временная сложность:** O(n log n)

**Почему O(n log n):** Глубина рекурсии — `O(log n)`, а на каждом уровне выполняется работа `O(n)` по слиянию подмассивов. Перемножение этих величин дает `O(n log n)`.

---

### **Анализ алгоритма: Сортировка Шелла (Shell Sort)**
**Определение:**
Сортировка Шелла (Shell Sort) — это алгоритм, который является обобщением сортировки вставками. Он сравнивает и сортирует элементы, находящиеся на определенном расстоянии друг от друга (с использованием последовательности шагов), постепенно уменьшая это расстояние до 1.

**Анализ:**
*   Алгоритм выполняет несколько проходов с разными значениями шага (расстояния между сравниваемыми элементами).
*   На начальных этапах с большим шагом он грубо сортирует массив, устраняя большое количество инверсий.
*   На последнем этапе (шаг = 1) выполняется обычная сортировка вставками, но на почти отсортированном массиве, что очень эффективно.
*   Временная сложность сильно зависит от выбранной последовательности шагов.

**Временная сложность:** O(n log² n) (для лучших последовательностей)

**Почему O(n log² n):** Алгоритм выполняет несколько проходов (логарифмическое количество) с разными шагами. На каждом проходе, благодаря большому шагу, количество операций линейно зависит от `n`, но с уменьшающимся коэффициентом. Для сложных последовательностей это дает оценку лучше квадратичной, но хуже чем `O(n log n)`.

---

### **Анализ алгоритма: Быстрая сортировка (Quick Sort)**
**Определение:**
Быстрая сортировка (Quick Sort) — это алгоритм, который использует стратегию "разделяй и властвуй". Он выбирает опорный элемент (pivot) и переупорядочивает массив так, чтобы все элементы меньше опорного оказались слева от него, а все большие — справа, после чего рекурсивно применяется к двум подмассивам.

**Анализ:**
*   Эффективность алгоритма критически зависит от выбора опорного элемента.
*   В среднем случае при случайном выборе опора массив делится на две примерно равные части.
*   Глубина рекурсии в среднем случае составляет `O(log n)`.
*   На каждом уровне рекурсии выполняется операция разделения (partition), которая обрабатывает все элементы текущего подмассива — в сумме на уровне `O(n)`.

**Временная сложность:** O(n log n) (средний случай)

**Почему O(n log n):** В среднем случае глубина рекурсии — `O(log n)`, а работа на каждом уровне — `O(n)`. Перемножение дает `O(n log n)`. В худшем случае (плохой выбор опора) глубина рекурсии становится `O(n)`, а сложность — O(n²).

---

### **Анализ алгоритма: Пирамидальная сортировка (Heap Sort)**
**Определение:**
Пирамидальная сортировка (Heap Sort) — это алгоритм, который использует структуру данных "двочная куча" (binary heap). Сначала массив преобразуется в max-кучу, где наибольший элемент находится в корне, затем этот элемент перемещается в конец массива, и куча перестраивается для оставшихся элементов.

**Анализ:**
*   Алгоритм состоит из двух этапов: построение кучи и собственно сортировка.
*   Построение max-кучи из неупорядоченного массива выполняется за `O(n)` операций.
*   Затем выполняется `n-1` операция извлечения максимума: замена корня с последним элементом и перестройка кучи.
*   Каждая операция перестройки кучи (heapify) имеет сложность `O(log n)`.

**Временная сложность:** O(n log n)

**Почему O(n log n):** Построение кучи — `O(n)`, а затем выполняется `n` операций перестройки кучи сложностью `O(log n)`. Доминирующая часть — `n * log n`, что дает общую сложность `O(n log n)`.

---

### **Анализ алгоритма: Последовательный (линейный) поиск (Linear Search)**
**Определение:**
Последовательный поиск (Linear Search) — это алгоритм, который последовательно проверяет каждый элемент массива от начала до конца, пока не будет найден искомый элемент или не будет достигнут конец массива.

**Анализ:**
*   Алгоритм начинает сравнение с первого элемента и продолжает до последнего.
*   В лучшем случае искомый элемент находится на первой позиции.
*   В худшем случае элемента нет в массиве или он находится на последней позиции, поэтому требуется проверить все `n` элементов.
*   В среднем случае потребуется проверить примерно `n/2` элементов.

**Временная сложность:** O(n)

**Почему O(n):** Количество операций сравнения в худшем и среднем случае линейно зависит от количества элементов в массиве `n`.

---

### **Анализ алгоритма: Бинарный поиск (Binary Search)**
**Определение:**
Бинарный поиск (Binary Search) — это алгоритм для нахождения позиции элемента в отсортированном массиве. На каждом шаге алгоритм сравнивает искомый элемент с элементом в середине текущего диапазона и, в зависимости от результата сравнения, отбрасывает одну из половин диапазона.

**Анализ:**
*   Алгоритм требует предварительной сортировки массива.
*   На каждом шаге размер области поиска уменьшается вдвое.
*   После первой итерации остается `n/2` элементов для поиска, после второй — `n/4`, затем `n/8` и т.д.
*   Процесс продолжается до тех пор, пока не будет найден элемент или область поиска не станет пустой.

**Временная сложность:** O(log n)

**Почему O(log n):** Количество шагов, необходимых для уменьшения области поиска с `n` элементов до 1, логарифмически зависит от `n` (основание логарифма — 2).

---

### **Анализ алгоритма: Интерполирующий поиск (Interpolation Search)**
**Определение:**
Интерполирующий поиск (Interpolation Search) — это алгоритм для нахождения элемента в отсортированном массиве, который использует значения искомого элемента и границ диапазона для предсказания его вероятной позиции (по принципу поиска в телефонной книге).

**Анализ:**
*   Алгоритм работает аналогично бинарному поиску, но вместо деления диапазона пополам вычисляет вероятную позицию элемента с помощью интерполяционной формулы.
*   Эффективен только для равномерно распределенных данных.
*   В среднем случае количество шагов значительно меньше, чем у бинарного поиска.

**Временная сложность:** O(log log n) (в среднем для равномерного распределения)

**Почему O(log log n):** На каждом шаге алгоритм не просто уменьшает диапазон вдвое, а пытается сразу "угадать" близкую к элементу позицию, что приводит к гораздо более быстрому сужению области поиска — двойной логарифм от `n`.

---

### **Анализ алгоритма: Поиск по Фибоначчи (Fibonacci Search)**
**Определение:**
Поиск по Фибоначчи (Fibonacci Search) — это алгоритм для нахождения элемента в отсортированном массиве, который использует числа Фибоначчи для определения позиций сравнения. Он делит массив на две части, размеры которых являются последовательными числами Фибоначчи.

**Анализ:**
*   Алгоритм похож на бинарный поиск, но использует сложение и вычитание вместо деления, что может быть эффективнее в некоторых системах.
*   Как и бинарный поиск, требует отсортированного массива.
*   На каждом шаге алгоритм исключает из рассмотрения примерно 1/3 массива.

**Временная сложность:** O(log n)

**Почему O(log n):** Алгоритм также уменьшает размер области поиска, но делает это с помощью чисел Фибоначчи. Поскольку числа Фибоначчи растут экспоненциально, количество требуемых шагов логарифмически зависит от `n`.
