Алгоритмы сортировки
------------------------------------------------------------------------------------------------------------------------------------------------------

1. Сортировка выбором (Selection Sort)

Определение: Алгоритм на каждом шаге находит минимальный (или максимальный) элемент в неотсортированной части массива и меняет его местами с первым элементом неотсортированной части.
Анализ: Алгоритм очень прост для понимания, но неэффективен на больших массивах. Его основное преимущество — он совершает минимальное количество обменов элементов (O(n)).

Временная сложность: O(n²)

Почему такая сложность? Независимо от исходного порядка элементов, алгоритм всегда выполняет примерно n(n-1)/2 сравнений. Внешний цикл проходит по всем n элементам, а внутренний цикл каждый раз ищет минимум в неотсортированной части, размер которой уменьшается с n до 1.

------------------------------------------------------------------------------------------------------------------------------------------------------
2. Сортировка обменом (пузырьком) (Bubble Sort)

Определение: Алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Проходы повторяются до тех пор, пока массив не будет отсортирован.
Анализ: Как и сортировка выбором, это учебный алгоритм, неэффективный на практике. Единственное преимущество — простота реализации. Можно оптимизировать, останавливаясь, если за проход не было ни одного обмена (массив уже отсортирован).

Временная сложность: O(n²)

Почему такая сложность? В худшем случае (массив отсортирован в обратном порядке) требуется n проходов по массиву (который имеет длину n), что приводит к O(n²) операциям. В лучшем случае (отсортированный массив) оптимизированная версия сделает один проход за O(n).

------------------------------------------------------------------------------------------------------------------------------------------------------
3. Сортировка вставками (Insertion Sort)

Определение: Алгоритм строит отсортированную последовательность, по одному элементу за раз, вставляя каждый новый элемент в правильную позицию в уже отсортированной части.
Анализ: Эффективен на небольших или частично отсортированных массивах. На практике часто используется в комбинированных алгоритмах (например, Timsort) для сортировки маленьких подмассивов. Является стабильной сортировкой.

Временная сложность:O(n²)

Почему такая сложность? В худшем случае (массив отсортирован в обратном порядке) для вставки каждого нового элемента придется сдвигать всю отсортированную часть, что требует 1 + 2 + ... + (n-1) = O(n²) операций. В лучшем случае (массив уже отсортирован) для каждого элемента потребуется только одно сравнение, итого O(n).

------------------------------------------------------------------------------------------------------------------------------------------------------
4. Сортировка слиянием (Merge Sort)

Определение: Алгоритм использует стратегию "разделяй и властвуй". Он рекурсивно разбивает массив на две половины, сортирует их, а затем сливает два отсортированных подмассива в один.
Анализ: Очень надежный и эффективный алгоритм. Его главные преимущества — гарантированная временная сложность O(n log n) и устойчивость. Недостаток — требует дополнительной памяти O(n).

Временная сложность:O(n log n)

Почему такая сложность? Массив делится пополам на log n уровней. На каждом уровне процесса слияния выполняется операция слияния, общая стоимость которой на всех уровнях равна O(n). Таким образом, общая сложность — O(n) * O(log n) = O(n log n).

------------------------------------------------------------------------------------------------------------------------------------------------------
5. Сортировка Шелла (Shell Sort)

Определение: Является обобщением сортировки вставками. Сравниваются и меняются местами элементы, стоящие на определенном расстоянии (шаге). Шаг постепенно уменьшается до 1, после чего алгоритм завершается обычной сортировкой вставками.
Анализ: Сложность для анализа, так как зависит от выбора последовательности шагов. На практике работает гораздо лучше, чем O(n²), и не требует дополнительной памяти. Эмпирическая сложность около O(n^(1.2 - 1.3)) для хороших последовательностей.

Временная сложность:O(n²) 

Почему такая сложность? На начальных этапах с большим шагом алгоритм делает "грубые" правки, которые значительно уменьшают количество инверсий. Последний проход с шагом 1 (обычная сортировка вставками) работает с почти отсортированным массивом, что очень быстро (~O(n)).

------------------------------------------------------------------------------------------------------------------------------------------------------
6. Быстрая сортировка (Quick Sort)

Определение: Алгоритм также использует "разделяй и властвуй". Он выбирает опорный элемент (pivot) и переупорядочивает массив так, чтобы все элементы меньше опорного оказались слева, а больше — справа. Затем алгоритм рекурсивно применяется к двум подмассивам.
Анализ: На практике часто является самым быстрым алгоритмом сортировки общего назначения. Однако его худший случай O(n²) может быть достигнут при неудачном выборе опорного элемента (например, всегда минимальный или максимальный). Версии с рандомизированным выбором опорного элемента делают худший случай маловероятным.

Временная сложность:O(n²)

Почему такая сложность? В среднем случае массив делится на две примерно равные части, что дает глубину рекурсии log n, а на каждом уровне выполняется работа O(n) по разбиению. Итого O(n log n). В худшем случае массив делится на части размером n-1 и 1, что приводит к глубине рекурсии n и общей сложности O(n²).

------------------------------------------------------------------------------------------------------------------------------------------------------
7. Пирамидальная сортировка (Heap Sort)

Определение: Алгоритм использует структуру данных "двочная куча" (binary heap). Сначала массив преобразуется в кучу (max-heap), где наибольший элемент находится в корне. Затем этот элемент перемещается в конец массива, а куча перестраивается для оставшихся элементов.
Анализ: Надежный алгоритм с гарантированной сложностью O(n log n). Не требует дополнительной памяти и часто используется в системах реального времени благодаря предсказуемому времени работы. На практике обычно медленнее, чем хорошо реализованная быстрая сортировка.

Временная сложность:O(n log n)

Почему такая сложность? Построение кучи из неупорядоченного массива выполняется за O(n). Затем выполняется n извлечений максимального элемента из кучи. Каждое извлечение (и последующая перестройка кучи) занимает O(log n). Итоговая сложность: O(n) + O(n log n) = O(n log n).
Алгоритмы поиска

------------------------------------------------------------------------------------------------------------------------------------------------------
8. Последовательный (линейный) поиск (Linear Search)

Определение: Простейший алгоритм поиска, который последовательно проверяет каждый элемент массива до тех пор, пока не будет найден искомый элемент или не будет достигнут конец массива.
Анализ: Применим к неотсортированным массивам. Очень неэффективен для больших данных.

Временная сложность: O(n)

Почему такая сложность? В худшем случае (элемента нет или он последний) алгоритму придется проверить все n элементов.

------------------------------------------------------------------------------------------------------------------------------------------------------
9. Бинарный поиск (Binary Search)

Определение: Эффективный алгоритм для поиска в отсортированном массиве. На каждом шаге сравнивает искомый элемент с элементом в середине массива. Если они не равны, отбрасывается половина массива, в которой искомого элемента точно нет, и поиск продолжается в оставшейся половине.
Анализ: Очень быстрый, но требует предварительной сортировки массива.

Временная сложность:O(log n)

Почему такая сложность? На каждом шаге область поиска уменьшается вдвое. Вопрос: "Сколько раз нужно делить n на 2, чтобы получить 1?". Ответ — log₂(n).

------------------------------------------------------------------------------------------------------------------------------------------------------
10. Интерполирующий поиск (Interpolation Search)

Определение: Улучшение бинарного поиска для равномерно распределенных отсортированных данных. Вместо деления массива пополам, он пытается угадать позицию искомого элемента на основе его значения (по принципу поиска в телефонной книге).
Анализ: Очень эффективен для больших, равномерно распределенных массивов. В среднем показывает сложность O(log log n), но деградирует до O(n) для неудачных распределений.

Временная сложность:O(n)

Почему такая сложность? Алгоритм "угадывает" позицию, используя линейную интерполяцию. Для равномерного распределения это позволяет находить элемент за количество шагов, пропорциональное log log n, что намного быстрее бинарного поиска.

------------------------------------------------------------------------------------------------------------------------------------------------------
11. Поиск по Фибоначчи (Fibonacci Search)

Определение: Еще один алгоритм для отсортированных массивов, использующий числа Фибоначчи. Он делит массив на две части, размеры которых являются последовательными числами Фибоначчи.
Анализ: Похож по производительности на бинарный поиск. Основное потенциальное преимущество — он использует только операции сложения и вычитания, что может быть полезно в некоторых системах с ограничениями (где деление дорого).

Временная сложность:O(log n)

Почему такая сложность? Алгоритм также делит область поиска, но делает это с помощью чисел Фибоначчи. Количество шагов пропорционально log n, так же как и в бинарном поиске.
